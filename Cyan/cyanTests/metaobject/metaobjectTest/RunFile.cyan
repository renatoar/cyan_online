package metaobjectTest

@doc{*
    
    This metaobject works like action_afterResTypes_semAn but the 
    Myan code is read from the file that is the first parameter. So, instead 
    of putting  the Myan code attached to the annotation, it is read from 
    the file,  which may be preceded by a package name. The file should have 
    extension myan and be in the â€“-data directory of the package. Usage example:
    
        @runFile_afterResTypes_semAn("runFile_afterResTypes_semAn.afterResTypes_semAn_test",
           "with:1 do:1", "unary", 10)
           
    The Myan file can have parameters in its name. They are textually 
    replaced by the parameters of the annotation (but the first, that is 
    the file name). Then, in this example, there should be a file
    
        afterResTypes_semAn_test(MetSig,UMS,Ret).myan
        
    in directory metaobjectTest\--data. Inside the file, strings Ret, 
    the third formal parameter, are replaced by 10. The same with the 
    other parameters.
    
    The methods of the Myan file can declare methods of the following
    interfaces:
        IAction_dpa
        IAction_semAn
        IActionNewPrototypes_semAn
        IAction_afterResTypes
        IActionNewPrototypes_afterResTypes
        ICommunicateInPrototype_afterResTypes_semAn_afterSemAn
*}
object RunFile

    func run {
        var Int nowExist = 0;
        var String currentProgramUnitName = "";
        
        /*
           Run file --data/afterResTypes_semAn_test(MetSig,UMS,Ret).myan
           of the directory of package metaobjectTest.
           
           This file will:
               - add the code
                    fp = "c";
                 before the first statement of method "with:1 do:1"
               - add the code
                    unaryReturn = 10;
                 before the first statement of method 'unary' 
               - add to the current prototype the method
                   func succ: Int n -> Int = n + 1;
               - add the code after the annotation:
                   nowExist = 5; 
                   currentProgramUnitName = "RunFile";
        */
        @runFile("afterResTypes_semAn_test", "with:1 do:1", "unary", 10)
        
        // runFile add 'c' before 'a' and then the 
        // anonymous function adds 'b' before "ca"
        assert with: "a" do: { (: String s :) 
            ^ "b" ++ s
            } == "bca";
        // unary was changed by 'runFile': unaryReturn is set to 10
        assert unary == 10;
        // method succ: was introduced by 'runFile'
        assert succ: 1 == 2;
        // nowExist was set to 5 by code generated by 'runFile'
        assert nowExist == 5;
        // currentProgramUnitName was set to RunFile by 'runFile'
        assert currentProgramUnitName == "RunFile";
        //printexpr currentProgramUnitName;
    }
    
    func with: String s do: Function<String, String> f -> String {
        fp = fp ++ s;
        return f eval: fp;
    }
    
    func unary -> Int {
        return unaryReturn;
    }
    
    var String fp = "";
    var Int unaryReturn = 0;
end

