package metaobjectTest


@doc{*
      Annotation 'fsmMethod' should be attached to a prototype. The parameter
      name is optional. If present, it should be an identifer. The metaobject
      creates a reset method with name 'resetFSM_Methods' or with the name
      of the parameter. This method resets the FSM to the initial state.
      
      q0, "q0q0:1" -> q0
      q0, "q0q1:2" -> q1
      q1, "q1:2 q1:1" -> q1
      q1, "q1q2" -> q2
      q2, "q2:0 q0:3" -> q0
  
*}
@fsmDSLMethods(resetFSM){*

   [. initialState = "r0",
      finalStates = [ #r1, #r2, #r3 ],
      states = [ #r0, #r1, #r2, #r3 ],
      transitions = [ 
        [. #r0, #r0, "q0q0:1" .],
        [. #r0, #r1, "q0q1:2" .],
        [. #r1, #r1, "q1:2 q1:1" .],
        [. #r1, #r2, "q1q2" .],
        [. #r2, #r3, "q2:0 q0:3" .]
        ]
      .]    
*}  
object FSM_DSL_Method

    func run {
        q0q0: "a";
        q0q0: "a";
        q0q0: "a";
        q0q1: 0, 1;
        for elem in 1..3 {
            q1: 0, 1 q1: "a";
        }
        q1q2;
        q2: q0: 0, 'a', "a";
        
        resetFSM;
        assert count == 9;
        var Boolean ok = false;
        {
            q0q0: "aa";
            q1: 0, 1 q1: "a";
        }
        catch: { (: CyException e :) 
            "wrong transition from q0q0 to q1:2 q1:1" println;
            ok = true;
        };
        assert ok && count == 10;
        
        resetFSM;
        FSM_DSL_Method() test0;
        resetFSM;
        FSM_DSL_Method() test1;
        resetFSM;
        FSM_DSL_Method() test2;
        resetFSM;
        FSM_DSL_Method() test3;
        resetFSM;
        FSM_DSL_Method() test4;
        
    }
    
    func q0q0: String s { 
        ++count;
        "after q0q0:1" println;
    }
    func q0q1: Int n, Int p { 
        ++count;
        "after q0q1:2" println;
    }
    func q1: Int n, Int p q1: String s { 
        ++count;
        "after q1:2 q1:1" println;
    }
    func q1q2 { 
        ++count;
        "after q1q2" println;
    }
    func q2: q0: Int a, Char ch, String s {
        ++count;
        "after q2:0 q0:3" println;
    }

    func test0 {
        q0q0: "aa";
        q0q0: "aa";
        q0q1: 0, 0;
        assert count == 3;
    }
    
    func test1 {
        var Boolean ok = false;
        {
            q0q0: "aa";
            q0q0: "aa";
            q0q1: 0, 0;
            q0q0: "aa";
            
        }
        catch: { (: CyException e :) 
            "wrong transition from q0q1:2 to q0q0:1" println;
            ok = true;
        };
        assert ok;        
        assert count == 3;
    
    }
    
    func test2 {
        q0q0: "aa";
        q0q0: "aa";
        q0q1: 0, 0;
        q1q2;
        assert count == 4;
    }
    
    func test3 {
        var Boolean ok = false;
        {
            q0q0: "aa";
            q0q0: "aa";
            q0q1: 0, 0;
            q1q2;
            q2: q0: 0, 'a', "a";
            q1: 0, 0 q1: "a"
        }
        catch: { (: CyException e :) 
            "wrong transition from q2:0 q0:3 to q1:2 q1:1" println;
            ok = true;
        };
        assert ok;        
        assert count == 5;
    }

    func test4 {
        q0q0: "aa";
        q0q0: "aa";
        q0q1: 0, 0;
        q1q2;
        resetFSM;
        q0q0: "aa";
        assert count == 5;
    } 

    
    @property var Int count = 0;
end

