package metaobjectTest

@doc{*
    addFieldInfo takes two parameters. The first is an identifier id.
    The second can be either 'counter' or 'names'. If it is 'counter', 
    the metaobject creates a field
        let Int id = number of fields in the prototype;
    and a method
        func counter_id -> Int = number of methods in the prototype;
        
    If the second parameter is 'names', the metaobject creates a field
        let Array<String> id = [ / * field names * /   ];
        
    This object tests the 'run until fixed point' feature of the Cyan MOP.
    This is because a metaobject may add fields and methods and therefore
    triggers changes in other metaobjects. The metaobject methods are
    called until they stop changing their outputs.
*}
@addFieldInfo(first, counter)
@addFieldInfo(second, names)
@addFieldInfo(third, counter)
@addFieldInfo(fourth, names)

object AddFieldInfo

    func aaa -> Int = 0;
    func bbb: Int n { }
    func ccc: Int n ddd: String s -> String = s ++ n;

    var Int eee = 0;
    var String fff = "fff";

    func run {
        printexpr first;
        Out println: "calling counter_first = " ++ counter_first;
        printexpr second;
        printexpr third;
        Out println: "calling counter_third = " ++ counter_third;
        printexpr fourth;
    }

   
end

/*
    // this is the code added to prototype AddFieldInfo by the
    // four metaobjects

    let Int first = 6;
    func counter_first -> Int = 7;
    let Array<String> second = [ "eee", "fff", "first", "second", "third", "fourth" ];
    let Int third = 6;
    func counter_third -> Int = 7;
    let Array<String> fourth = [ "eee", "fff", "first", "second", "third", "fourth" ];

*/







