package main

import cyan.util
import grammar

@checkStyle
object Program 

    func init {
        age = 11;
        monthDay = 14;
        _name = "Newton";
        _college = "Cambridge";
    }



    func run {


        let ln00 = @lineNumber;
        assert true;
        let ln11 = @lineNumber;
        let ln22 = @lineNumber;
        assert ln11 == ln00 + 2;
        assert ln22 == ln11 + 1;
        assert ln00 == ln11 - 2;

        let ln0 = @compilationInfo("linenumber");
        let ln1 = @compilationInfo("linenumber");
        let ln2 = @compilationInfo("linenumber");
        assert ln1 == ln0 + 1;
        assert ln2 == ln1 + 1;
        assert ln0 == ln1 - 1;
        if @compilationInfo("linenumber")-@compilationInfo("linenumber") != 0 {
            var lineN = @lineNumber-1;
            "assert failed in line $lineN of 'Program'" println;
        }

        if @compilationInfo("linenumber")*@lineNumber < 0 {
            var lineN = @lineNumber-1;
            "assert failed in line $lineN of 'Program'" println;
        }

        /* printexpr Program one;
        printexpr Program two;
        printexpr Program three;  */
        
    
        var Strange<ProtoT, ProtoR> strange;
        var Tuple<name, String, age, Int> .# writeCode livia, carol;
        var Tuple<f1, String, f2, Int> ttt = 
            [. f1 = "Carol", f2 = 7 .];
        assert ttt f1 == "Carol";
        assert ttt f2 == 7;

        var s100 = Store<int_100>();
        var Boolean err = true;
        {
            s100 set: 99;
            s100 set: 100;
            err = false;
        } hideException;
        assert ! err;
        err = false;        
        {
            s100 set: 101;
            err = true;
        } hideException;
        assert !err;

        GrammarTest() run;
        
        functionTest;
        grammarTest;
        getSetTest;
        conceptTest;
        createPrototypeTest;
        addMethodsToArrayTest;
    
        let n00 = 0FFFF_base16;
        assert n00 == 65535;
        let b00 = 10101bin;
        assert b00 == 21;
        // 255_255_255_47IP println;
    
        /*
        let pf0 = @packageFeature("cyan.util") asString;
        assert pf0 == "[ [. key = annot, value = This is cyan.util .], [. key = poption, value = package debug .], [. key = poption, value = [ optimize, very, much ] .], [. key = annot, value = [ [. f1 = masterMOP, f2 = MOP master, f3 = 12345 .] ] .], [. key = pname, value = [ [ 0, 1 ], [ 2, 3 ] ] .] ]";
        
        pf0 println;
        ("*" * 20) println;
        @packageFeature("cyan.util", "poption") println;
        ("*" * 20) println;
        @packageFeature("cyan.util", "pname") println;
        ("*" * 20) println;
        @packageFeature("cyan.util", "") println;
        ("*" * 20) println;
        */
        
        assert "C:\\Dropbox\\Cyan ###" == "C:" ++ '\\' ++ "Dropbox" ++ '\\' ++ "Cyan ###";
        assert "\\n $ \b\t $ \\t  ###" == 
               '\\' ++ 'n' ++ " $ " ++ '\b' ++ '\t' ++ " $ " ++ '\\' ++ 't' ++ "  ###";
        assert "\\n $ \b\t $ \\t  ###" != 
               "\\n $ " ++ '\\' ++ "b\t $ \\t  ###";



        let fn = @compilationInfo(filename);
        assert fn == "C:\\Dropbox\\Cyan\\cyanTests\\masterMOP\\main\\Program.cyan";

        let t0 = @compilationInfo(filename) ++ " filename ";
        assert t0 == "C:\\Dropbox\\Cyan\\cyanTests\\masterMOP\\main\\Program.cyan filename ";


        var Int n = 0;
        let okbin = 101bin;
        assert okbin == 5 && 00111BIN == 7 && 0FFFF_base16 == 65535;
        
        
        let text = "aab";
        let okre = !(text ~= r"[ab]a");
        assert okre;
        assert !(text ~= r"[ab]a");
           
        assert text ~= r"a*b";
        assert !(text ~= r"bc+");
        assert text ~= r"a+bc*";
        assert !(text ~= r"bb+c+");
        
        /*
        if text ~= r"a*b" {
            "has a*b" println;
        }
        if text ~= r"bc+" {
            "has bc+" println;
        }
        
        if text ~= r"a+bc*" {
            "has a+bc*" println;
        }
        if text ~= r"bb+c+" {
            "has bb+c+" println;
        }
        @compilationInfo(filename) println;
        @compilationInfo("prototypename") println;
        @compilationInfo(packagename) println;
        
        @compilationInfo("localvariablelist") println;
        @compilationInfo("fieldlist") println;
        @compilationInfo("signatureallmethodslist") println;
        
        let t1 = @compilationInfo("fieldlist") ++ " ivlist";
        let t2 = @compilationInfo("fieldlist") size;
        let t3 = "ivlist = " ++ @compilationInfo("fieldlist") ++ " ";
        
        t0 println;
        t1 println;
        t2 println;
        t3 println;
        */
        
        assert @compilationInfo(filename) == n"C:\Dropbox\Cyan\cyanTests\masterMOP\main\Program.cyan";
        let fileName = @compilationInfo(filename);
        assert fileName == n"C:\Dropbox\Cyan\cyanTests\masterMOP\main\Program.cyan";

        assert @compilationInfo("prototypename") == "Program";
        var Proto p = Proto();
        p at: 1 put: 'a';
        p at: 2 put: 'b';
        p at: 3 put: 'c';
        assert p getText == "1a2b3c";
        
        
        let mil = @extract(int_1000);
        let dois222 = { let d2 = @extract(int2222); ^d2 } eval;
        assert mil == 1000 && dois222 == 2222;
        
        
        assert (aa: "", 0 bb: 'a' cc: 0.0) == "aa:2 bb:1 cc:1";
        assert (aa: "", 0 bb: 'a' cc: 0.0 dd:) == "aa: String, Int bb: Char cc: Double dd: -> String";
        assert self abc == "cyan.lang.String";
        
        other.Taint() run;
        testPluggableTypes.PluggableTypesTest<Int>() run;
        
        FileTest run;
        
        Proto run;
        
        "end of masterMOP" println;
    }
    
    
    func at: Int k put: String s {
    }
    
    func abc -> String = @compilationInfo(currentMethodReturnTypeName);
    
    func aa: String a, Int b bb: Char c cc: Double -> String = @compilationInfo(currentMethodName);
    func aa: String a, Int b bb: Char c cc: Double dd: -> String = @compilationInfo(currentMethodFullName);

    
    func myself -> Program .# writeCode = Program;


    func grammarTest {
        let IntSet is3 = IntSet();
        is3 add: 0, 1, 2;
        var sum = 0;
        var prod = 1;
        for elem in is3 getSet {
            sum = sum + elem;
            if elem != 0 {
                prod = prod*elem;
            }
        }
        assert sum == 3 && prod == 2;
        is3 addEach: 3 addEach: 4 addEach: 5;
        sum = 0;
        prod = 1;
        for elem in is3 getSet {
            sum = sum + elem;
            if elem != 0 {
                prod = prod*elem;
            }
        }
        assert sum == 15 && prod == 120;        
    }

    Int aaa = 0;
    Int bbb = 1;
    String ccc = "2";
    String ddd = "3";
    String eee = "4";
    
    
    func functionTest {
        let Array<String> strArray = Array<String>();
        let Function<String, Nil> addMethod = strArray functionForMethod: "add:1";
        addMethod eval: "A";
        addMethod eval: "B";
        assert strArray size == 2;
        assert strArray[0] == "A" &&
               strArray[1] == "B";
        
        var helpItem = MenuItem new;
        helpItem onMouseClick: (Help functionForMethod: "show" );
        var openItem = MenuItem new;
        openItem onMouseClick: (FileMenu functionForMethod: "open");
        
        assert helpItem action == 0;
        assert openItem action == 1;
        
        let Test t = Test();
        let IMap<String, Function<Int, Int>> methodMap = [ 
            "add10" -> (t functionForMethod: "add10:1"),
            "twice" -> (t functionForMethod: "twice:1"),
            "cube"  -> (t functionForMethod: "cube:1")
            ];
        cast f = methodMap["twice"] {
            assert f eval: 3 == 6;
        }
        else {
            assert false;
        }
        cast f = methodMap["add10"] {
            assert f eval: 3 == 13;
        }
        else {
            assert false;
        }
        cast f = methodMap["cube"] {
            assert f eval: 3 == 27;
        }
        else {
            assert false;
        }
        
    }


    
    
    func getSetTest {

        assert getAge == 11 && getMonthDay == 14 &&
             name == "Newton" && college == "Cambridge";
                 
        /* printexpr getAge;
        printexpr getMonthDay;
        printexpr name;
        printexpr college; */
        
        self setAge: 22;
        self setMonthDay: 28;
        self name: "Godel";
        self college: "IEA";

        /* printexpr getAge;
        printexpr getMonthDay;
        printexpr name;
        printexpr college;  */

        assert getAge == 22 && getMonthDay == 28 &&
             name == "Godel" && college == "IEA";
             
        setAge: (getAge + 8);
        setMonthDay: (getMonthDay + 2);
        name: (name ++ " K.");
        college: (college ++ " Princeton");

        assert getAge == 30 && getMonthDay == 30 &&
             name == "Godel K." && college == "IEA Princeton";

        assert Program getSharedFixed == "sharedFixed";
        assert getFixed == "fixed";
        assert underFixed == "underFixed";
        assert Program underSharedFixed == "underSharedFixed";
        /*
        printexpr fixed;
        printexpr sharedFixed;
        printexpr underFixed;
        printexpr underSharedFixed;
        */
        
    }
    
    func conceptTest {
        var GroupWork<IntGroupPlus> gwi = GroupWork<IntGroupPlus> new;
        var a = IntGroupPlus(1);
        var b = IntGroupPlus(5);
        var c = IntGroupPlus(11);
        var zero = IntGroupPlus(0);
        assert a inverse inverse == a;
        assert a unit == zero;
        assert a * a inverse == zero;
        assert a * a unit == a;
        assert (b inverse * a inverse) * a * b == a unit;
        assert (c inverse * b inverse * a inverse) * a * b * c == zero;

        assert b * b * a == c && c * b inverse * a inverse == b;
        
        GroupWork<IntGroupPlus> work: a, b, c;
        GroupWork<IntGroupPlus> workout: a, b, c;
        
        conceptPackage.ConceptTest() run;
    }

    @createPrototype(
          "Dragon", 
          "package main\nobject Dragon\n    func get -> Int { return 0 }\n\nend",
          
          "Elf", 
          "package main\nobject Elf\n    func get -> String { return \"Elf !\" }\n\nend"
    )
    
    func createPrototypeTest {
    
        let Dragon dragon = Dragon new;
        assert dragon get == 0;
        assert Elf() get == "Elf !";
    }
    

    func addMethodsToArrayTest {
    
        // "addMethodsToArrayTest" println;
        var intArray = [ 1, 2, 3 ];
    
        let funcArray = [ { ^1 }, { ^2 }, { ^3 } ];
        assert funcArray sum == 6;
        funcArray add: { ^4 };
        assert funcArray sum == 10;
        
    
        assert intArray sum == 6;
        
        var matriz = [ [ 1, 2, 3 ],
                       [ 4, 5, 6 ],
                       [ 7, 8, 9 ] ];
        assert matriz sumDiagonal == 1 + 5 + 9;
        
        assert matriz flat == [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
        
    
        var Array<String> as = [ "c", "b", "a" ];
        assert as sort == [ "a", "b", "c" ];
        
        assert as sortDescending == [ "c", "b", "a" ];
        as = [ "e", "a", "c", "b", "d" ];
        assert as sort == [ "a", "b", "c", "d", "e" ];
        assert as sortDescending == [ "e", "d", "c", "b", "a" ];
        
        var ap = [ "first", "second", "third" ];
        
        
        assert ap join == "firstsecondthird";
        assert (ap join: ", ") == "first, second, third";

        assert as join == "edcba";
        assert (as join: ", ") == "e, d, c, b, a";
        
        ap = [ "one" ];

        assert ap join == "one";
        assert (ap join: ", ")  == "one";

    }

    @property var Int age;
    @property var Int monthDay;
    @property var String _name;
    @property var String _college;

    @property String fixed = "fixed";
    @property shared String sharedFixed = "sharedFixed";

    @property String _underFixed = "underFixed";
    @property shared String _underSharedFixed = "underSharedFixed";
        
end




